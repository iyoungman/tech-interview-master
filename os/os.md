## TOC

<!-- TOC -->

- [TOC](#toc)
- [운영체제 정의](#운영체제-정의)
- [운영체제 기능](#운영체제-기능)
- [운영체제 분류 기준](#운영체제-분류-기준)
- [운영 체제의 자원 관리 기능](#운영-체제의-자원-관리-기능)
    - [HW 구성도](#hw-구성도)
- [하이퍼스레딩](#하이퍼스레딩)
- [CPU 스케줄링](#cpu-스케줄링)
- [Context Switching](#context-switching)
- [프로세스, 스레드 동기화](#프로세스-스레드-동기화)
- [세마포와 뮤텍스의 차이](#세마포와-뮤텍스의-차이)
- [가상메모리](#가상메모리)
- [메모리 관리 전략](#메모리-관리-전략)
    - [단편화](#단편화)
- [Paging 교체 알고리즘](#paging-교체-알고리즘)

<!-- /TOC -->

***

## 운영체제 정의
* `프로세스, 자원 등을 효율적으로 관리하기 위한 SW`  
* 컴퓨터 HW 바로 윗단에 설치되는 SW  
![image](https://user-images.githubusercontent.com/25604495/83218686-6688ae80-a1a9-11ea-8a78-42f16b943c6a.png)  
* 컴퓨터 전원을 On 했을 시 OS가 없으면 컴퓨터는 고철 덩어리에 불과하다.
* SW가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 적재 되어야 한다.
* OS도 하나의 SW로서 전원이 켜짐과 동시에 메모리에 적재된다.
* 따라서 OS 중 항상 필요한 부분만 메모리에 적재
그렇지 않은 부분은 필요할 때 메모리에 적재 후 사용
* 이 때 메모리에 상주하는 OS의 부분을 `커널(Kernel)`이라 부르며 이를 좁은 의미의 OS라고도 한다.
    * 핵심 연산을 처리한다.
즉 커널은 OS 코드 중에서도 핵심적인 부분을 뜻한다.

***

## 운영체제 기능
* 프로세스 관리
* 자원 관리

***

## 운영체제 분류 기준
1. 동시 작업 지원
* 시분할 시스템
    * 다중 작업 지원 OS라 하더라도 일반적으로 CPU는 한개.
    * 동시성은 CPU가 번갈아 가면서 처리하는 것이다.
    * CPU 처리속도가 빨라 동시에 수행되는 것처럼 보이는것
    * 이렇게 CPU의 작업시간을 여러 프로그램이 나눠 쓰는 시스템을 `시분할 시스템`

* 다중 프로그래밍 시스템
    * CPU와 달리 메모리의 경우 여러 프로그램들이 메모리 공간을 보유하며
    * 동시에 메모리에 올라갈 수 있다.
    * 이처럼 메모리 공간을 분할해 여러 프로그램을 동시에 메모리에 올려 처리하는것을 `다중 프로그래밍 시스템`

* 다중 처리기 시스템
    * 하나의 컴퓨터에 여러 개 CPU 설치된 경우


<br>

2. 다중 사용자의 동시 지원 여부
* 한 번에 한 명의 사용자만 사용
    * 단일 사용자용 OS
* 여러 사용자가 동시 접속 사용
    * 다중 사용자용 OS
* 서버 컴퓨터는 다중 사용자용 OS

<br>

3. 작업을 처리하는 방식
* 일괄 처리
* 시분할 방식
* 실시간

***

## 운영 체제의 자원 관리 기능
* `OS 핵심은 자원을 효율적으로 관리 = HW + SW 자원`
* HW 자원 = CPU와 메모리를 비롯해 주변 장치 및 입출력 장치 등
* 여러 프로세스들이 CPU, 메모리 등을 효율적으로 나누어 사용할 수 있도록 관리되어야 함
* CPU와 메모리는 전원 Off 시 데이터가 모두 지워지기 때문에
`저장되어야할 데이터는 보조 기억 장치에 파일 형태로 저장된다`.
* 이러한 파일들이 저장되는 방식 및 접근 권한 등에 대해서도 OS가 관리

### HW 구성도  
> HW 라는것 기억  

![image](https://user-images.githubusercontent.com/25604495/83219668-e9126d80-a1ab-11ea-8489-5f8c3f40c9ea.png)  
![image](https://user-images.githubusercontent.com/25604495/83220516-25df6400-a1ae-11ea-8041-ee0356c4670d.png)  

> 보조 기억장치도 외부 장치이다.
>
> 주기억장치 : 빠르다, 휘발성
>
> 보조기억장치 : 느리다, 비휘발성

* 참고
    * https://minwan1.github.io/2018/06/23/2018-06-23-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80[OS-2]/

***

* CPU 관리방법
    * 일반적인 컴퓨터에는 CPU가 하나밖에 없지만 프로세스는 여러 개가 동시에 실행된다.
    * 어떤 시점에 어떠한 프로세스에게 CPU를 할당할 것인지가 `CPU 스케줄링`

***

* 메모리(RAM) 관리방법
    * CPU가 직접 접근할 수 있는 내부 기억 장치
    * 프로그램이 CPU에서 수행되려면 해당 부분이 메모리에 적재되어야 한다.
    * OS는 프로그램에게 메모리가 필요할 때 할당, 더 이상 필요하지 않게 될 경우 회수한다.

* 물리적 메모리 관리 방식
1) 고정 분할 방식
2) 가변 분할 방식
3) 가상 메모리 방식

***

주변 장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트(Interrupt)라는 매커니즘을 통해 관리

주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청
이 때 발생시키는 신호를 인터럽트라 한다.

***

```text

```

## 하이퍼스레딩
* 인텔이 멀티스레딩을 위해 구현.

* 코어는 물리적인 개념
    * 코어는 각종 연산을 하는 CPU의 요소.
* `하나의 코어가 여러 스레드를 가질수 있도록 인식하는 기술.`
* 즉, 컴퓨터의 코어가 8개이면 논리 프로세서는 16으로 인식한다.



***

```text

```

## CPU 스케줄링
* 스케줄링
    - `OS 스케줄러가 주체.`
    - 프로세스를 특정한 우선순위로 할당
    - 멀티 프로세싱의 효율적인 처리를 위해서
      
* FCFS(First Come First Served)
    - 비선점형
    - 효율성 낮다
      
* SJF(Shortest - Job - First)
    - 비선점형
    - CPU birst time 짧은 것 선할당
    - 기아상태(긴것은 영원히 할당 못받는다)
      
* SRT(Shortest Remaining time First)
    - SJF의 선점형버전
    - 새로운 프로레스 도착할때마다 새로운 스케줄링
    - 현재것보다 더 짧은 프로세스가 도착하면 뺏긴다
    - 기아상태(긴것은 영원히 할당 못받는다)
      
* Priority Scheduling
    - 선점형, 비선점형 가능
    - 우선순위(중요도)에 따라
    - 기아상태(우선순위 낮은건 영원히 할당 못받는다)
  
* Aging
    - 기아상태 해결방법
    - 우선순위가 낮은 프로세스는 오래 기다리면 우선순위를 높여주자
  
* Round Robin
    - 현대적인 CPU 스케줄링
    - 각 프로세스는 동일한 할당 시간(time quantum), 할당 시간이 지나면 ready queue의 제일 뒤에 가서 다시 줄을 선다(context switching)
    - CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우 효율적이다
    - 장점 : 공정한 스케줄링
    - 단점 : time quantum을 잘 조절해야한다(너무 작으면 잦은 context switching으로 overhead, 너무 크면 FCFS와 같아진다)
    - context switching은 CPU에 프로세스가 바꼈을 때 횟수이다(처음 X)
    - https://blog.naver.com/jhnyang/221502772494  
* 선점, 비선점
    - 선점 : 이미 할당된 자원 다른 프로세스가 강탈
    - 비선점 : 강탈 불가능

***

```text

```

## Context Switching
* 멀티 프로세싱 환경에서<br>
CPU가 프로세스를 실행하다가<br>
다음 우선순위의 프로세스로 교체하는 작업.  

<br>

* Context
    * CPU가 해당 프로세스를 실행하기 위한 프로세스 정보들.  
    
<br>

* PCB(프로세스 제어 블록)  
    * 프로세스의 정보들은 저장하는 공간.  
    * 위의 Context 정보들은 PCB에 적재된다.  
    * `위치는 주기억장치에 위치한다.`  
    * `Context Switching을 위해 필요하다.`  
    * `해당 프로세스가 하던 작업을 이어서 해야하기 때문이다.`    
    
<br>

* 참고
    * https://jeong-pro.tistory.com/93?category=793347
    * https://jhnyang.tistory.com/33

***

```text

```

## 프로세스, 스레드 동기화
* 동기화란?
    * 여러 프로세스가 공유된 자원에 접근할때
    * 프로세스의 수행시점을 조절하는 것
* 임계영역(멀티 프로세싱, 멀티 스레딩)
    - 동일한 자원을 여러 군데서 접근하는 영역

* 해결방법(Locking의 종류)

> HW 기반 동기화
* 락
    * 임계구역 진입 프로세는 Lock을 획득, 나올때는 UnLock, 시간적 효율성 떨어진다.

***

> OS 기반 동기화
1) 세마포어(카운팅)
 * 사용 가능한 공유자원의 개수를 나타내는 변수(서버에 프린트 5대 물려있으면 5, 누군가 사용하면 1감소)`

2) 뮤텍스(이진)
* 상호배제와 연관, 0 또는 1만 가능, 공유자원 1개가 비어있으면 1 누군가 사용하고 있으면 0

3) 모니터
* 고급 언어 설계 구조물
* Java의 경우 `synchronized` 키워드 같은 것에 해당

***

> 동기화의 문제점
* `Deadlock(교착 상태) : 서로가 상대방 자원을 기다리며 무기한 대기하는 상태`

* 발생 조건
1) 상호배제(Mutual exclusion) : 한 자원에 대한 여러 프로세스 동시 접근 불가.  
2) 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.  
3) 비선점(No preemption) : 다른 프로세스 자원을 강제로 가져올 수 없는 것.  
4) 순환대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.  

* Deadlock 해결
1) 예방
* 교착 상태 발생은 4가지 모두가 만족해야한다.
* 발생조건 4가지 중 한가지라도 해결
2) 회피
3) 회복
4) 무시
* https://junsday.tistory.com/32


***

```text

```

## 세마포와 뮤텍스의 차이
* 세마포는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포가 될 수 없다.
* `뮤텍스는 동기화 대상이 하나, 세마포는 동기화 대상이 여러개가 될때 사용`

* 세마포
    * 정수 값을 가지는 변수
    * `접근할 수 있는 최대 허용치만큼 동시 사용자 접근 가능`
    * `동기화 대상 자원이 여러개 있을 때 사용`
* 뮤텍스
    * 정수 값을 가지는 변수
    * `0 또는 1만 가진다.`

***

```text

```

## 가상메모리
* 메모리의 공간이 부족할 떄
* `보조기억장치를 이용.`
* 메모리의 내용일 쓰고 읽는 과정이 있으므로 속도는 느리다.
* https://namu.wiki/w/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC  

<br>

* `페이징과 세그멘테이션이있다.`


***

```text

```

## 메모리 관리 전략
* OS가 메모리의 효율적 관리를 위한것.

> 방법

`1) 연속 할당 기법(물리적 방식)`
* [1] 단일 분할 할당
    * Swapping
        * Swap-in(CPU할당 시간이 된 프로세스를 RAM<-보조기억장치, 메모리 공간이 부족할 때 사용)
* [2] 다중 분할 할당
    * 고정 분할 할당
    * 가변 분할 할당

***

`2) 분산 할당(가상 방식)`
* [1] 페이징
    * `외부 단편화 해결, 논리 메모리를 고정된 일정하게 분할`
    * `물리 메모리의 연속적이지 않은 공간도 할당 가능`
    * 동적 배치 허용
    * 참고
        * https://jeong-pro.tistory.com/91
        * https://developerhenrycho.tistory.com/22

![image](https://user-images.githubusercontent.com/25604495/83715693-fd9dac80-a668-11ea-8786-45e6b79c8fa8.png)  

* [2] 세그멘테이션
    * `내부 단편화 해결, 논리 메모리를 가변영역으로 분할`  
    * https://blog.naver.com/PostView.nhn?blogId=qbxlvnf11&logNo=221368476938&parentCategoryNo=&categoryNo=&viewDate=&isShowPopularPosts=false&from=postView

![image](https://user-images.githubusercontent.com/25604495/83715644-e5c62880-a668-11ea-8c30-07b7e15c8ae9.png)

***

> 분산 할당 문제와 해결

### 단편화
* 메모리의 공간을 연속적인 형태로 할당.
* `사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태.`  
* https://huisam.tistory.com/entry/6-Memory-Fragmentation

![image](https://user-images.githubusercontent.com/25604495/83714429-aea24800-a665-11ea-8dbf-ad1015be8dea.png)

<br>

1) 내부 단편화
* 어떠한 프로세스가 필요한 양 보다 더 큰 메모리 할당하여<br>
메모리 공간이 낭비되고 있는 것.

2) 외부 단편화
* 메모리가 할당되고 해제되는 상태에서 메모리 중간중간에 안쓰는 메모리 생긴다.
* `총 메모리 공간은 충분하지만 할당이 불가능한 상태`

* 해결
    * 압축

***

* 참고
    * https://storyofsol.tistory.com/96


***

```text

```

## Paging 교체 알고리즘
* LRU
    - `Least Recently Used`
    - 가장 오랫동안 사용하지 않은 페이지를 교체
* 최적 페이지 교체
    - 구현이 어렵다
    - 앞으로 가장 오랫동안 사용하지 않을 페이지 교체