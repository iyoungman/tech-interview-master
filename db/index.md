
## TOC

<!-- TOC -->

- [TOC](#toc)
- [인덱스](#인덱스)
- [인덱스 종류 중 B-Tree를 가장 많이 사용하는 이유(vs HashTable)](#인덱스-종류-중-b-tree를-가장-많이-사용하는-이유vs-hashtable)
- [인덱스 컬럼은 어떻게 잡을까?](#인덱스-컬럼은-어떻게-잡을까)
- [인덱스 확인](#인덱스-확인)
- [장점](#장점)
- [단점](#단점)
- [인덱스 파일 구조](#인덱스-파일-구조)
- [인덱스 주의점](#인덱스-주의점)

<!-- /TOC -->

***

## 인덱스
* 조회성능 향상을 위한 DB 객체
* 따로 파일로 저장된다
    * InnoDB
    * MyISAM
        * MYI 파일

***

## 인덱스 종류 중 B-Tree를 가장 많이 사용하는 이유(vs HashTable)
> 해시 인덱스도 있지만 동등 비교만 가능하기 때문이다.

1) B Tree는 하나의 노드에 여러 데이터를 가질 수 있다 -> 검색 용이

> 트리는 깊이를 줄여야 검색 성능이 좋다
>
> 하나의 노드에 여러 데이터를 가지면 트리 깊이가 줄어든다.

2) 리프노드의 Level도 동일하다 -> 데이터 검색의 균형

3) HashTable은 동등연산에 적합('=') 
> `하지만 Select 조건에는 등호('<', '>')도 있다`

4) LogN의 시간복잡도
> 삽입, 삭제, 탐색 모두 트리의 높이와 관련있다
>
> 하나의 노드에 여러값이 들어갈 수 있기 때문에 트리의 높이를 줄일 수 있다

***

## 인덱스 컬럼은 어떻게 잡을까?
* 중복도가 낮은 것 (= 카디널리티가 높은 것)
* 원하는 데이터 이외에 최대한 많은 데이터 걸러져야 하므로.
* 중복되는 데이터가 많을 수록 Full Scan에 가까워지므로.

***

## 인덱스 확인

```sql
show index from board_tbl;
```

***

## 장점
* 검색 속도 향상

***

## 단점
* Index 된 필드에서 데이터를 조작(Create, Update, Delete) 할 때 성능이 떨어진다.
    * 단, Insert, Delete, Update 자체가 느려지긴하지만
    * 해당 데이터를 찾을때의 속도는 증가함에 주의.
    * `따라서, 데이터 조작이 빈번한 컬럼에는 Index를 안 거는게 좋다.`

***

## 인덱스 파일 구조
* Index를 생성하는 컬럼의 값
* 해당 ROW의 주소


***

## 인덱스 주의점


***
